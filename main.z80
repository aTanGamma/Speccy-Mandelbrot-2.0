;   A 'simple' mandlebrot generator at full resolution bitmap

;Documentation in the Readme

    DEVICE ZXSPECTRUM48


/*----= Global Variables =----*/

Current_X = $8000   ;Location of current X coord (16-bit, fixed point)
Current_Y = $8002   ;Location of current Y coord (16-bit, fixed point)

X_Byte = $8006  ;Screen byte number (0 - 31) ──┐
X_Pixel = $8004 ;The X-pos in px on the screen ├───> For working out Screen Address
Line_No = $8005 ;Scanline number ──────────────┘
;^ In reverse order for loading into bc

Byte_To_Fill_0 = $8007
Byte_To_Fill_1 = $8008

No_Iterations = $8009

State = $800A   ;Used to determine what to do

LastKeys = $800B    ;3 bytes for all keys pressed last frame to stop multipressing
                    ;Hexadecimal digits, break and enter

/*----= Definitions =----*/


_INITIAL_X = $E000  ;-2
_INITIAL_Y = $1000  ;+1

_X_STEP_SIZE = $0050    ;+ 2.5/128 = 0000.0000 0011 0000 
_Y_STEP_SIZE = $FFAB    ;- 2/96    = 1111.1111 1010 1011

/*
_INITIAL_X = $F000  ;- 1.0000 = 1111.0000 0000 0000
_INITIAL_Y = $0500  ;+ 0.3125 = 0000.0101 0000 0000

_X_STEP_SIZE = $0004    ;+ 0.50/256 = 0000.0000 0000 0100
_Y_STEP_SIZE = $FFFC    ;- 0.25/96 = 1111.1111 1111 1100
*/

_BORDER_COLOUR = 0 ;Black border

_MAX_ITERATIONS = 16
_MIDS_THRESHOLD = 12
_DARK_THRESHOLD = 8

_SCREEN_BITMAP_START = $4000
_BITMAP_LENGTH = $1800

_COLOUR_ATTRIBUTES_START = $5800
_COL_ATR_LENGTH = $0300

_WHITE_BLACK = %01000111    ;no flash, bright, black paper, white ink

_FONT_LOCATION = $6000  ;Also the first Character
_MENU_DATA = $6800

/*----= Main Code =----*/

    org $4000

    INCBIN "LoaderImage_V2.bin"

    org $8100

    INCLUDE "StateMachine.z80"

    MODULE Calculate

Setup

Clear_Screen

    ld a, 0
    ld (_SCREEN_BITMAP_START), a
    ld de, _SCREEN_BITMAP_START+1
    ld bc, _BITMAP_LENGTH
    ld hl, _SCREEN_BITMAP_START

    ldir

Set_Attributes

    ld a, _WHITE_BLACK
    ld hl, _COLOUR_ATTRIBUTES_START
    ld (hl), a
    ld de, _COLOUR_ATTRIBUTES_START+1
    ld bc, _COL_ATR_LENGTH

    ldir

Set_Border

    ld a, _BORDER_COLOUR
    out (254), a  ;Set border colour Black

Preset_Variables

    ld a, 0
    ld (X_Byte), a
    ld (X_Pixel), a
    ld (Line_No), a
    ld (Byte_To_Fill_0), a
    ld (Byte_To_Fill_1), a    ;Reset screen stuff

    ld bc, _INITIAL_X
    ld (Current_X),bc
    ld (Iterator.Working_X),bc

    ld bc, _INITIAL_Y
    ld (Current_Y),bc
    ld (Iterator.Working_Y),bc

Iterator

    call Iterator.Init  ;Returns #iterations in a

Determine_Pixel_State

    cp _MAX_ITERATIONS

    jr z, Rotate_In_2_Pixels  ;Skip if iterations < MAX

    cp _MIDS_THRESHOLD ;Compare to threshold to see whether to shade
    jr nc, Rotate_In_Mid_Shaded

    cp _DARK_THRESHOLD ;Compare to threshold to see whether to shade
    jr nc, Rotate_In_Dark_Shaded

    jp Rotate_In_2_Blank

Rotate_In_2_Pixels
    
    ld a, (Byte_To_Fill_0)
    sll a
    sll a
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sll a
    sll a
    ld (Byte_To_Fill_1), a    ;Put 2 pixel in a holding byte (will be plotted every 4 px)

    jp Inc_X_Px

Rotate_In_Mid_Shaded    ;sll is fine, just undocumented for some reason

    ld a, (Byte_To_Fill_0)
    sla a
    sll a
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sll a
    sla a
    ld (Byte_To_Fill_1), a  ;Put 2 pixel in a holding byte (will be plotted every 4 px)

    jp Inc_X_Px

Rotate_In_Dark_Shaded

    ld a, (Byte_To_Fill_0)
    sla a
    sla a
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sll a
    sla a
    ld (Byte_To_Fill_1), a  ;Put 2 pixel in a holding byte (will be plotted every 4 px)

    jp Inc_X_Px

Rotate_In_2_Blank

    ld a, (Byte_To_Fill_0)
    sla a
    sla a
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sla a
    sla a
    ld (Byte_To_Fill_1), a    ;Put 2 pixel in a holding byte (will be plotted every 4 px)

Inc_X_Px

    ld a, %00010110
    out ($FE), a
    .8 nop
    ld a, 4
    out ($FE), a    ;Sound code

    ld hl, X_Pixel    ;Increment Pixel position
    inc (hl)
    ld a, $03    ;Xpx % 4
    and(hl)

    jr z, Inc_X_Byte

Step_X_Coord

    ld bc, (Current_X)
    ld hl, _X_STEP_SIZE

    add hl, bc  ;Step X coord to next pixel

    ld (Current_X), hl  ;Return to memory

    jp Iterator ;Now calculate the next pixel

Inc_X_Byte

    ld a, (Byte_To_Fill_0)
    ld bc, (Line_No)
    call Byte_Plotter.Start ;Plot finished byte
    ld a, (Byte_To_Fill_1)
    ld bc, (Line_No)
    inc c
    call Byte_Plotter.Start ;Duplicate 1 line down

    xor a
    ld (Byte_To_Fill_0), a
    ld (Byte_To_Fill_1), a

    ld hl, X_Byte
    inc (hl)    ;Step to next byte
    ld a, %00011111
    and (hl)

    jr nz, Step_X_Coord ;If next byte != 32 (or 0), step X as usual

    xor a
    ld (X_Byte), a  ;Reset to 0

Inc_Line_No

    ld a, (Line_No)
    add 2
    ld (Line_No), a

    cp 192  ;Changed to do full screen
    jr z, Done

Reset_X_Pos

    ld bc, _INITIAL_X
    ld (Current_X), bc  ;Reset X_Pos

Step_Y_Coord

    ld bc, (Current_Y)
    ld hl, _Y_STEP_SIZE

    add hl, bc

    ld (Current_Y), hl

    jp Iterator

Done

    ld a, 1
    ld (State), a

Calc_Done_Wait4Key

    ld a, (State)
    cp $FF
    jp z, State_Machine.Draw_Menu_Init
    
    jr Calc_Done_Wait4Key


    ENDMODULE

    INCLUDE "Iterator.z80"

    INCLUDE "Maths.z80"

    INCLUDE "Interrupt_Stuff.z80"

    INCLUDE "Menu.z80"

    SAVESNA "Mandel.sna", State_Machine.Start

    SAVETAP "Mandel.tap", State_Machine.Start