;   A 'simple' mandlebrot generator at full resolution bitmap

;Documentation in the Readme

    DEVICE ZXSPECTRUM48


/*----= Global Variables =----*/

Current_X = $8000   ;Location of current X coord (16-bit, fixed point)
Current_Y = $8002   ;Location of current Y coord (16-bit, fixed point)

X_Byte = $8006  ;Screen byte number (0 - 31) ──┐
X_Pixel = $8004 ;The X-pos in px on the screen ├───> For working out Screen Address
Line_No = $8005 ;Scanline number ──────────────┘
;^ In reverse order for loading into bc

Byte_To_Fill_0 = $8007
Byte_To_Fill_1 = $8008

No_Iterations = $8009


Timer = $800A

/*----= Definitions =----*/

/*
_INITIAL_X = $E000  ;-2
_INITIAL_Y = $1000  ;+1

_X_STEP_SIZE = $0050    ;+ 2.5/128 = 0000.0000 0011 0000 
_Y_STEP_SIZE = $FFAB    ;- 2/96    = 1111.1111 1010 1011
*/

_INITIAL_X = $F000  ;- 1.0000 = 1111.0000 0000 0000
_INITIAL_Y = $0500  ;+ 0.3125 = 0000.0101 0000 0000

_X_STEP_SIZE = $0004    ;+ 0.50/256 = 0000.0000 0000 0100
_Y_STEP_SIZE = $FFFC    ;- 0.25/96 = 1111.1111 1111 1100


_BORDER_COLOUR = 0 ;Black border

_MAX_ITERATIONS = 256
_MIDS_THRESHOLD = 64
_DARK_THRESHOLD = 32

_SCREEN_BITMAP_START = $4000
_BITMAP_LENGTH = $1800

_COLOUR_ATTRIBUTES_START = $5800
_COL_ATR_LENGTH = $0300

_WHITE_BLACK = %01000111    ;no flash, bright, black paper, white ink

_FONT_LOCATION = $A000  ;Also the first Character

/*----= Main Code =----*/

    org $4000

    INCBIN "LoaderImage_V2.bin"

    org $8100

    MODULE Main_Loop


Start

;   Rough layout:

;   Clear screen & Attributes
;   setup loop for line:
;     > Set up loop for byte
;     > Iterate each pixel and plot result in byte
;     > After 8 pixels, increment hl for next byte & plot byte
;     > After 32, move to next line


    di

    im 2
    ld a, $39   ;Makes interrupt jump to somewhere in page $39xx - All bytes are $FF
    ld i, a     ;CPU then goes to location $FFFF to execute a relative jump, which happens to make jr $F3, so a jp can be put 13 bytes behind $FFFF

    ei

Main

    call Setup.Clear_Screen

Iterator

    call Iterator.Init  ;Returns #iterations in a

Determine_Pixel_State

    ld (No_Iterations), a

    or a
    cp _MAX_ITERATIONS

    jr z, Rotate_In_2_Pixels  ;Skip if iterations < MAX

    or a
    cp _MIDS_THRESHOLD ;Compare to threshold to see whether to shade
    jr nc, Rotate_In_Mid_Shaded

    or a
    cp _DARK_THRESHOLD ;Compare to threshold to see whether to shade
    jr nc, Rotate_In_Dark_Shaded

    jp Rotate_In_2_Blank

Rotate_In_2_Pixels
    
    ld a, (Byte_To_Fill_0)
    sla a
    sla a
    add a,3
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sla a
    sla a
    add a,3
    ld (Byte_To_Fill_1), a    ;Put 2 pixel in a holding byte (will be plotted every 4 px)

    jp Inc_X_Px

Rotate_In_Mid_Shaded

    ld a, (Byte_To_Fill_0)
    sla a
    sla a
    add a,1
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sla a
    sla a
    add a,2
    ld (Byte_To_Fill_1), a  ;Put 2 pixel in a holding byte (will be plotted every 4 px)

    jp Inc_X_Px

Rotate_In_Dark_Shaded

    ld a, (Byte_To_Fill_0)
    sla a
    sla a
    add a,0
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sla a
    sla a
    add a,2
    ld (Byte_To_Fill_1), a  ;Put 2 pixel in a holding byte (will be plotted every 4 px)

    jp Inc_X_Px

Rotate_In_2_Blank

    ld a, (Byte_To_Fill_0)
    sla a
    sla a
    ld (Byte_To_Fill_0), a

    ld a, (Byte_To_Fill_1)
    sla a
    sla a
    ld (Byte_To_Fill_1), a    ;Put 2 pixel in a holding byte (will be plotted every 4 px)

Inc_X_Px

    ;ld a, %00010100
    ;out ($FE), a
    ;.16 nop
    ld a, 4
    out ($FE), a

    ld a, (X_Pixel)
    inc a
    ld (X_Pixel), a ;Increment Pixel position

    and %00000011   ;Xpx % 4

    jr z, Inc_X_Byte

Step_X_Coord

    ld bc, (Current_X)
    ld hl, _X_STEP_SIZE

    add hl, bc  ;Step X coord to next pixel

    ld (Current_X), hl  ;Return to memory

    jp Iterator ;Now calculate the next pixel

Inc_X_Byte

    ld a, (Byte_To_Fill_0)
    ld bc, (Line_No)
    call Xor_Byte_Plotter.Start ;Plot finished byte
    ld a, (Byte_To_Fill_1)
    ld bc, (Line_No)
    inc c
    call Xor_Byte_Plotter.Start ;Duplicate 1 line down

    xor a
    ld (Byte_To_Fill_0), a
    ld (Byte_To_Fill_1), a

    ld a, (X_Byte)
    inc a
    ld (X_Byte), a  ;Step to next byte

    and %00011111   ;Byte# % 32

    jr nz, Step_X_Coord ;If next byte != 32 (or 0), step X as usual

    xor a
    ld (X_Byte), a  ;Reset to 0

Inc_Line_No

    ld a, (Line_No)
    add 2
    ld (Line_No), a

    cp 192  ;Changed to do full screen

    jr z, Done

Reset_X_Pos

    ld bc, _INITIAL_X
    ld (Current_X), bc  ;Reset X_Pos to -2

Step_Y_Coord

    ld bc, (Current_Y)
    ld hl, _Y_STEP_SIZE

    add hl, bc

    ld (Current_Y), hl

    jp Iterator

Done

    di

    ;INCLUDE "Timer_Msg.z80"


End
    jp End
    im 1
    ei

    halt

    ret

    ENDMODULE

    MODULE Setup

Clear_Screen

    ld a, 0
    ld (_SCREEN_BITMAP_START), a
    ld de, _SCREEN_BITMAP_START+1
    ld bc, _BITMAP_LENGTH
    ld hl, _SCREEN_BITMAP_START

    ldir

Set_Attributes

    ld a, _WHITE_BLACK
    ld hl, _COLOUR_ATTRIBUTES_START
    ld (hl), a
    ld de, _COLOUR_ATTRIBUTES_START+1
    ld bc, _COL_ATR_LENGTH

    ldir

Set_Border

    ld a, _BORDER_COLOUR
    out (254), a  ;Set border colour Black

Preset_Variables

    ld a, 0
    ld (X_Byte), a
    ld (X_Pixel), a
    ld (Line_No), a
    ld (Byte_To_Fill_0), a
    ld (Byte_To_Fill_1), a    ;Reset screen stuff

    ld (Timer), a
    ld (Timer+1), a
    ld (Timer+2), a     ;Reset Timer

    ld bc, _INITIAL_X
    ld (Current_X),bc
    ld (Iterator.Working_X),bc

    ld bc, _INITIAL_Y
    ld (Current_Y),bc
    ld (Iterator.Working_Y),bc

    ret

    ENDMODULE





    INCLUDE "Iterator.z80"

    INCLUDE "Maths.z80"

    INCLUDE "Interrupt_Stuff.z80"

    org _FONT_LOCATION
    INCLUDE "Font.z80"


    SAVESNA "mandle.sna", Main_Loop.Start

    SAVETAP "Tape.tap", Main_Loop.Start